\section{WireGuard} \label{wireguard}

WireGuard ist ein sehr modernes und junges VPN-Protokoll, welches darauf abzielt, ältere, aktuell dominierende Protokolle wie OpenVPN oder IPsec abzulösen. Dabei setzt sich WireGuard das Ziel, schneller, sicherer und einfacher zu sein als seine Konkurrenten. Des Weiteren ist WireGuard ein Open-Source \gl{VPN}-Protokoll, welches von Jason A. Donenfeld entwickelt wurde und 2015 veröffentlicht wurde. \cite{Wireguard_Whitepaper, Wireguard_Presentations}

In den letzten Jahren hat WireGuard zunehmend Annahme in verschiedenen Produkten gefunden, wie VPN-Anbieter NordVPN \cite{NordLynx} oder Mullvad \cite{Mullvad_Wireguard}, Router Hersteller wie Unifi \cite{Unifi_Wireguard} oder AVM \cite{AVM_Wireguard}, Mikrocontroller Software wie ESPHome \cite{ESPHome_Wireguard} und \acrfull{SDN} Lösungen wie Tailscale \cite{Tailscale} oder ZeroTier \cite{ZeroTier}. Die Resonanz war bis jetzt äußerst positiv und spricht den versprochenen Vorteilen von WireGuard zu. Zusätzlich zeigt es auch, wie flexibel WireGuard sich einsetzen lässt, von 

In diesem Kapitel werden wir einmal die Architektur von WireGuard erläutern und anschaulich an einem beispielhaften Kommunikationsablauf erklären, das Protokoll und die grundlegende Kryptografie erklären und wie aktuelle Implementierungen aussehen.

\subsection{Architektur}

Das Kernprinzip von WireGuard ist sehr einfach, jeder Teilnehmer im Netzwerk wird durch einen öffentlichen Schlüssel identifiziert und besitzt die gleichen grundlegenden Funktionalitäten. Jeder Teilnehmer kann dabei sowohl als Client als auch als Server fungieren, was eine hohe Flexibilität und Skalierbarkeit ermöglicht. Die Authentifizierung und der Aufbau der Verbindungen erfolgen ausschließlich über den Austausch von öffentlichen Schlüsseln, wodurch komplexe Konfigurationsdateien und Zertifikate überflüssig werden.

Ein wesentlicher Bestandteil von WireGuard ist das virtuelle Netzwerkinterface \texttt{wg0} (Standardname des WireGuard Interfaces), welches authentifizierten Datenverkehr auf Layer 3 Ebene auf das System zulässt. Das Interface kann hier mit den klassischen System-Tools zur Konfiguration von Netzwerkschnittstellen und Datenverkehr verwaltet werden und läuft primär im Linux Kernel-Space. Auf anderen Plattformen wird jedoch auf das klassische TUN/TAP Interface zurückgegriffen, welches im User-Space der jeweiligen Plattform läuft. \cite{Wireguard_Whitepaper, Wireguard_cross_platform}

\subsection{Protokoll und Verschlüsselung}

Damit zwei Teilnehmer im Netzwerk sicher kommunizieren können, setzt WireGuard der Austausch der öffentlichen Schlüssel voraus. Des Weiteren muss einer der Teilnehmer eine Konfiguration als Server vornehmen, hierfür wird der entsprechende öffentliche Key des anderen Teilnehmer mit in die Konfiguration aufgenommen und einem Adressbereich zugewiesen. Der Client muss ebenfalls den öffentlichen Schlüssel des Servers sowie den zugewiesenen Adressbereich in der Konfiguration eintragen. \cite{Wireguard_Whitepaper}

WireGuard ermöglicht durch den Austausch des öffentlichen Schlüssels im Voraus und außerhalb der eigentlichen WireGuard-Verbindung, die Sicherheit des Schlüsselaustausches. Dadurch wird sichergestellt, dass nur autorisierte Teilenehmer an der Kommunikation teilnehmen können und es zu keinem unbefugten Zugriff kommt. Zusätzlich handelt sich bei dem öffentlichen Schlüssel um eine unbedenkliche Information, da durch das Konzept des öffentlichen und privaten Schlüssels, niemand die Identität des Schlüsseleigentümers alleine mit dem öffentlichen Schlüssel vortäuschen kann.

\begin{enumerate}
    \item \textbf{Handshake-Prozess}: Durch den Einsatz von modernen kryptografischen Techniken kann WireGuard einen Handshake mit nur zwei Nachrichten durchführen. Dieser Handshake basiert auf dem Noise-Protokoll-Framework und verwendet den Diffie-Hellman-Schlüsselaustausch über Curve25519. Der Client sendet eine Nachricht zum Einleiten des Handshakes an den Server, der darauf mit einer Antwortnachricht reagiert. Diese Nachrichten enthalten jeweils einen Teilschlüssel, die zur Ableitung eines gemeinsamen geheimen Sitzungsschlüssels genutzt werden.
    \item \textbf{Sicherer Datenaustausch}: Sobald der Handshake abgeschlossen ist und ein gemeinsamer Sitzungsschlüssel abgeleitet wurde, beginnt der sichere Datenaustausch. Die Datenpakete werden mit ChaCha20 verschlüsselt, was eine schnelle und sichere, symmetrische Verschlüsselung gewährleistet. Zusätzlich wird jede Nachricht mit Poly1305 authentifiziert, um die Integrität und Authentizität der Daten zu gewährleisten. Durch die Verwendung von Unbekannten bei der Verschlüsselung wird sichergestellt, dass jedes Datenpaket einzigartig ist und Replay-Angriffe verhindert werden.
    \item \textbf{Periodische Handshakes}: Um die Sicherheit der Verbindung dauerhaft zu gewährleisten, führt WireGuard regelmäßig neue Handshakes durch. Standardmäßig geschieht dies alle 120 Sekunden. Dies sorgt für eine regelmäßige Erneuerung der Sitzungsschlüssel, was das Risiko vom Kompromittierung reduziert und verhindert, neue Daten mit einem möglicherweise alten geknackten Schlüssel zu entschlüsseln.
\end{enumerate}

\subsection{Implementierung}

Ursprünglich wurde WireGuard speziell für den Linux-Kernel entwickelt und umfasste nur circa 4000 Zeilen Code. Somit lief das Programm nicht nur im Kernel für maximale Leistung, sondern war auch aufgrund der Größe leicht zu auditieren. Heute läuft WireGuard häufig auch im User-Space des jeweiligen Betriebssystems, um andere Plattformen zu unterstützen, verfolgt aber die gleiche grundlegende Implementation, um weiterhin leicht auditieren zu sein. \cite{Wireguard_cross_platform}

Ein zentrales Merkmal von WireGuard ist auch die einfache Einbettung des Protokolls in eigene Applikationen \cite{Wireguard_Embedding}, um den Einsatz der bereits geprüften Implementierung im eigenen Umfeld möglich zu machen. Zusätzlich zu der offiziellen WireGuard Entwicklung, gibt es bereits alternative Implementierungen des Protokolls wie von Cloudflare \cite{CloudflareBoringTun} oder OpenBSD \cite{OpenBSD_WireGuard}.